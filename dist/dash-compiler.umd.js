var B=Object.defineProperty;var k=Object.getOwnPropertySymbols;var E=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var F=(u,c,l)=>c in u?B(u,c,{enumerable:!0,configurable:!0,writable:!0,value:l}):u[c]=l,m=(u,c)=>{for(var l in c||(c={}))E.call(c,l)&&F(u,l,c[l]);if(k)for(var l of k(c))z.call(c,l)&&F(u,l,c[l]);return u};(function(u,c){typeof exports=="object"&&typeof module!="undefined"?c(exports,require("mc-project-core"),require("path-browserify")):typeof define=="function"&&define.amd?define(["exports","mc-project-core","path-browserify"],c):(u=typeof globalThis!="undefined"?globalThis:u||self,c(u.DashCompiler={},u.mcProjectCore,u.pathBrowserify))})(this,function(u,c,l){"use strict";class P extends c.ProjectConfig{constructor(i,t){super(l.dirname(t));this.fileSystem=i,this.configPath=t}readConfig(){return this.fileSystem.readJson(this.configPath)}writeConfig(i){return this.fileSystem.writeJson(this.configPath,i)}}function S(n){return H(n)(...Object.values(n.env))}function H({script:n,env:i,async:t=!1}){let e=j(n);try{return t?new Function(...Object.keys(i),`return (async () => {
${e}
})()`):new Function(...Object.keys(i),e)}catch(s){throw console.error(n),new Error(`Error within script: ${s}`)}}function j(n){return n.replace(/export default /g,"module.exports = ").replace(/import\s+(\* as [a-z][a-z0-9]*|[a-z][a-z0-9]+|{[a-z\s][a-z0-9,\s]*})\s+from\s+["'](.+)["']/gi,(i,t,e)=>(t.startsWith("* as ")&&(t=t.replace("* as ","")),`const ${t} = await require('${e}')`))}class v{constructor(i){this.plugin=i}runBuildStartHook(){var i,t;return(t=(i=this.plugin).buildStart)==null?void 0:t.call(i)}runIncludeHook(){var i,t;return(t=(i=this.plugin).include)==null?void 0:t.call(i)}runTransformPathHook(i){var t,e;return(e=(t=this.plugin).transformPath)==null?void 0:e.call(t,i)}runReadHook(i,t){var e,s;return(s=(e=this.plugin).read)==null?void 0:s.call(e,i,t)}runLoadHook(i,t){var e,s;return(s=(e=this.plugin).load)==null?void 0:s.call(e,i,t)}runRegisterAliasesHook(i,t){var e,s;return(s=(e=this.plugin).registerAliases)==null?void 0:s.call(e,i,t)}runRequireHook(i,t){var e,s;return(s=(e=this.plugin).require)==null?void 0:s.call(e,i,t)}runTransformHook(i,t,e){var s,r;return(r=(s=this.plugin).transform)==null?void 0:r.call(s,i,t,e)}runFinalizeBuildHook(i,t){var e,s;return(s=(e=this.plugin).finalizeBuild)==null?void 0:s.call(e,i,t)}runBuildEndHook(){var i,t;return(t=(i=this.plugin).buildEnd)==null?void 0:t.call(i)}}const R=({options:n,outputFileSystem:i,hasComMojangDirectory:t,projectConfig:e,projectRoot:s})=>{var p;n.buildName||(n.buildName=n.mode==="development"?"dev":"dist"),n.packName||(n.packName="Bridge"),((p=n.rewriteToComMojang)!=null?p:!0)||(t=!1);const r={BP:"development_behavior_packs",RP:"development_resource_packs",SP:"skin_packs",WT:"minecraftWorlds"},a=o=>t&&n.mode==="development"?`${r[o]}`:`${s}/builds/${n.buildName}`,f=o=>`${a(o)}/${n.packName} ${o}`;return{async buildStart(){if(n.mode==="production"||n.restartDevServer)if(t)for(const o in r)await i.unlink(f(o)).catch(()=>{}),await i.mkdir(f(o));else await i.unlink(a("BP")).catch(()=>{})},transformPath(o){if(!o||o.includes("BP/scripts/gametests/")&&n.mode==="production")return;const d=o.split("/"),h=d.shift();if(["BP","RP","SP","WT"].includes(h))return`${f(h)}/${d.join("/")}`}}};class A{constructor(i){this.dash=i,this.plugins=[]}async loadPlugins(i={}){var a,f,p;const t=[...(await this.dash.fileSystem.readdir(l.join(this.dash.projectRoot,".bridge/extensions")).catch(()=>[])).map(o=>o.kind==="directory"?l.join(this.dash.projectRoot,".bridge/extensions",o.name):void 0),...(await this.dash.fileSystem.readdir("extensions").catch(()=>[])).map(o=>o.kind==="directory"?l.join("extensions",o.name):void 0)],e={simpleRewrite:R.toString()};for(const o of t){if(!o)continue;let d;try{d=await this.dash.fileSystem.readJson(l.join(o,"manifest.json"))}catch{continue}if(!!((a=d==null?void 0:d.compiler)==null?void 0:a.plugins))for(const h in d.compiler.plugins)e[h]=l.join(o,d.compiler.plugins[h])}const s=(p=(f=this.dash.projectConfig.get().compiler)==null?void 0:f.plugins)!=null?p:[],r={};for(const o in e){const d=s.find(h=>typeof h=="string"?h===o:h[0]===o);d?r[e[o]]=typeof d=="string"?{}:d[1]:console.warn(`Missing plugin with name ${o}`)}for(const o in r){const d=o.startsWith("/")?await this.dash.fileSystem.readFile(o).then(g=>g.text()):o,h={};await S({async:!0,script:d,env:m({require:void 0,module:h},i)}),typeof h.exports=="function"&&this.plugins.push(new v(h.exports({options:m({mode:this.dash.getMode()},r[o]),fileSystem:this.dash.fileSystem,outputFileSystem:this.dash.outputFileSystem,projectConfig:this.dash.projectConfig,projectRoot:this.dash.projectRoot,targetVersion:this.dash.projectConfig.get().targetVersion,getAliases:g=>{var w,y;return[...(y=(w=this.dash.includedFiles.get(g))==null?void 0:w.aliases)!=null?y:[]]},hasComMojangDirectory:this.dash.fileSystem!==this.dash.outputFileSystem,compileFiles:g=>this.dash.compileVirtualFiles(g)})))}}async runBuildStartHooks(){for(const i of this.plugins)await i.runBuildStartHook()}async runIncludeHooks(){let i=[];for(const t of this.plugins){const e=await t.runIncludeHook();Array.isArray(e)&&i.push(...e)}return i}async runTransformPathHooks(i){let t=i;for(const e of this.plugins){const s=e.runTransformPathHook(t);if(s===null)return null;s!==void 0&&(t=s)}return t}async runReadHooks(i,t){for(const e of this.plugins){const s=await e.runReadHook(i,t);if(s!=null)return s}}async runLoadHooks(i,t){let e=t;for(const s of this.plugins){const r=await s.runLoadHook(i,e);r!==void 0&&(e=r)}return e}async runRegisterAliasesHooks(i,t){const e=new Set;for(const s of this.plugins){const r=await s.runRegisterAliasesHook(i,t);r!=null&&(Array.isArray(r)?r.forEach(a=>e.add(a)):e.add(r))}return e}async runRequireHooks(i,t){const e=new Set;for(const s of this.plugins){const r=await s.runRequireHook(i,t);r!=null&&(Array.isArray(r)?r.forEach(a=>e.add(a)):e.add(r))}return e}async runTransformHooks(i){const t=Object.fromEntries([...i.requiredFiles].map(s=>[s,this.dash.includedFiles.get(s)]));let e=i.data;for(const s of this.plugins){const r=await s.runTransformHook(i.filePath,e,t);r!==void 0&&(e=r)}return e}async runFinalizeBuildHooks(i){for(const t of this.plugins){const e=await t.runFinalizeBuildHook(i.filePath,i.data);if(e!=null)return e}}async runBuildEndHooks(){for(const i of this.plugins)await i.runBuildEndHook()}}class D{constructor(i,t){this.dash=i,this.filePath=t,this.isDone=!1,this.requiredFiles=new Set,this.aliases=new Set,this.outputPath=t,this.fileHandle={getFile:()=>this.dash.fileSystem.readFile(t)}}setOutputPath(i){this.outputPath=i}setReadData(i){this.data=i}setAliases(i){for(const t of i)this.dash.includedFiles.addAlias(t,this);this.aliases=i}setRequiredFiles(i){this.requiredFiles=i}async processAfterLoad(){(this.data===null||this.data===void 0)&&(this.isDone=!0,this.filePath!==this.outputPath&&this.outputPath!==null&&await this.dash.fileSystem.readFile(this.filePath))}}class b{constructor(i){this.dash=i,this.files=[],this.aliases=new Map}all(){return this.files}filtered(i){return this.files.filter(t=>i(t))}setFiltered(i){this.files=this.filtered(i)}get(i){var t;return(t=this.aliases.get(i))!=null?t:this.files.find(e=>e.filePath===i)}addAlias(i,t){this.aliases.set(i,t)}async loadAll(){const i=new Set,t=this.dash.projectConfig.getAvailablePackPaths();for(const s of t){const r=await this.dash.fileSystem.allFiles(s);for(const a of r)i.add(a)}const e=await this.dash.plugins.runIncludeHooks();for(const s of e)i.add(s);this.files=Array.from(i).map(s=>new D(this.dash,s))}}class C{constructor(i){this.dash=i}async run(){var i;for(const t of this.dash.includedFiles.all()){const[e,s]=await Promise.all([this.dash.plugins.runTransformPathHooks(t.filePath),this.dash.plugins.runReadHooks(t.filePath,t.fileHandle)]);t.setOutputPath(e),t.setReadData(s),await t.processAfterLoad()}for(const t of this.dash.includedFiles.all()){if(t.isDone)continue;t.setReadData((i=await this.dash.plugins.runLoadHooks(t.filePath,t.data))!=null?i:t.data);const[e,s]=await Promise.all([this.dash.plugins.runRegisterAliasesHooks(t.filePath,t.data),this.dash.plugins.runRequireHooks(t.filePath,t.data)]);t.setAliases(e),t.setRequiredFiles(s)}}}class T{constructor(i){this.dash=i}run(){const i=new Set;for(const t of this.dash.includedFiles.all())t.isDone||i.has(t)||this.resolve(t,i,new Set);return i}resolve(i,t,e){const s=this.dash.includedFiles;e.add(i);for(const r of i.requiredFiles){const a=s.get(r);if(!a)throw new Error(`Undefined file dependency: "${i.filePath}" requires "${r}"`);if(!t.has(a)){if(e.has(a))throw new Error("Circular dependency detected!");this.resolve(a,t,e)}}t.add(i),e.delete(i)}}function $(n){return typeof n=="string"||n instanceof Blob||n instanceof File||n instanceof ArrayBuffer||(n==null?void 0:n.buffer)instanceof ArrayBuffer}class q{constructor(i){this.dash=i}async run(i){var t,e;for(const s of i){const r=await this.dash.plugins.runTransformHooks(s);(t=s.data)!=null||(s.data=r);let a=(e=await this.dash.plugins.runFinalizeBuildHooks(s))!=null?e:r;a!==void 0&&a!==void 0&&($(a)||(console.warn(`File "${s.filePath}" was not in a writable format: "${typeof a}". Trying to JSON.stringify(...) it...`,a),a=JSON.stringify(a)),await this.dash.outputFileSystem.writeFile(s.filePath,a)),s.isDone=!0}}}class O{constructor(i,t=i,e={mode:"development",config:"config.json"}){this.fileSystem=i,this.outputFileSystem=t,this.options=e,this.plugins=new A(this),this.includedFiles=new b(this),this.loadFiles=new C(this),this.fileOrderResolver=new T(this),this.fileTransformer=new q(this),this.projectRoot=l.dirname(e.config),this.projectConfig=new P(i,e.config)}getMode(){return this.options.mode}async setup(){await this.projectConfig.setup(),await this.plugins.loadPlugins(this.options.pluginEnvironment)}get isCompilerActivated(){var i;return!!this.projectConfig.get().compiler||!Array.isArray((i=this.projectConfig.get().compiler)==null?void 0:i.plugins)}async build(){if(console.log("Starting compilation..."),!this.isCompilerActivated)return;const i=Date.now();await this.plugins.runBuildStartHooks(),await this.includedFiles.loadAll(),await this.loadFiles.run();const t=this.fileOrderResolver.run();console.log(t),await this.plugins.runBuildEndHooks(),console.log(`Dash compiled ${this.includedFiles.all().length} files in ${Date.now()-i}ms!`)}async compileVirtualFiles(i){}async updateFiles(i){}async unlink(i){}async rename(i,t){}watch(){}}class x{async allFiles(i){const t=[],e=await this.readdir(i);for(const{name:s,kind:r}of e)r==="directory"?t.push(...await this.allFiles(l.join(i,s))):r==="file"&&t.push(l.join(i,s));return t}async writeJson(i,t,e=!0){await this.writeFile(i,JSON.stringify(t,null,e?"	":0))}async readJson(i){return JSON.parse(await this.readFile(i).then(t=>t.text()))}watchDirectory(i,t){console.warn("Watching a directory for changes is not supported on this platform!")}}u.Dash=O,u.FileSystem=x,Object.defineProperty(u,"__esModule",{value:!0}),u[Symbol.toStringTag]="Module"});
